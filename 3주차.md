# 3주차

#### 1. 산술 연산자

프로그램에서 데이터를 처리하여 결과를 산출하는 것을 연산이라고 한다. 연산에 사용되는 표시나 기호를 연산자(operator)라고 한다.

산술 연산자에는 `+, -, *, /, %`가 있다. 산술연산자일 경우는 숫자타입(byte, short, int, long, float, double)으로 결과값이 나온다.

<img src="https://github.com/sungpillhong/whiteshipstudy/blob/master/screenshot/1.PNG"> </img>

<img src="https://github.com/sungpillhong/whiteshipstudy/blob/master/screenshot/1-1.PNG"> </img>



*는 곱하기, / 는 나누기를 하여 몫을 구하는 연산자이다.



<img src="https://github.com/sungpillhong/whiteshipstudy/blob/master/screenshot/2.PNG"> </img>



<img src="https://github.com/sungpillhong/whiteshipstudy/blob/master/screenshot/2-1.PNG"> </img>



%는 나머지를 구하는 연산자이다.

위처럼 `a=5, b=3`으로 가정하고 %를 하면 5를3으로나눈 나머지인 2가 나오게된다.

그렇다면 `int` 대신 `double`형을 사용한다면? 

<img src="https://github.com/sungpillhong/whiteshipstudy/blob/master/screenshot/3.PNG"> </img>



<img src="https://github.com/sungpillhong/whiteshipstudy/blob/master/screenshot/3-1.PNG"> </img>

가능하다.

산술연산자는 피연산자, 즉 연산되는 데이터인 a, b와 같은 변수가 단항(1개)일때는 사용하지 못하며, 이항(2개 이상)일때 계산식으로서 사용가능하다.



<img src="https://github.com/sungpillhong/whiteshipstudy/blob/master/screenshot/4.PNG"> </img>

이것은 왜 에러가나는가..?? 모두 정수타입이고 `int` 타입보다 크기가 작은 타입일 경우 모두 `int` 타입으로 변환 후 연산을 수행한다. 이는 자바 가상 머신(JVM)이 기본적으로 32비트 단위로 계산하기 때문이다.

산술 연산자의 특징은 피연산자들의 타입이 동일하지 않을 경우 다음과 같은 규칙을 사용해서 피연자들의 타입을 일치시킨 후 연산을 수행한다.

1. 피연산자들이 모두 정수 타입이고, int 타입(4type)보다 크기가 작은 타입일 경우 모두 int 타입으로 변환 후 연산을 수행한다. 따라서 연산의 산출타입은 int이다. 예) btye + byte -> int + int = int 

2. 피연산자들이 모두 정수 타입이고, long 타입이 있을 경우 모두 long 타입으로 변환 후, 연산을 수행한다. 따라서 연산의 산출 타입은 long이다.                                    예) int + long -> long + long = long 

3. 피연산자 중 실수타입(float, double)이 있을 경우, 크기가 큰 실수 타입으로 변환 후, 연산을 수행한다. 따라서 연산의 산출 타입은 실수 타입이다.                              

   예) int + double -> double + double = double

따라서 바로 위의 byte result를 수정하여 ``` int result = a+b;```로 실행시켜야 한다.

주의해야 할 점은 올바른 계산을 위해 값을 미리 검정해야하고, 정확한 계산을 위해 실수 타입을 피해야 하며, 특수 값 처리에 신경써야한다.





#### 2. 비트 연산자

비트 연산자는 데이터를 비트(bit) 단위로 연산한다. 즉, 0과 1이 피연산자가 된다. 그렇기 때문에 0과 1로 표현이 가능한 정수 타입만 비트 연산을 할 수 있다.

비트 연산자는 기능에 따라 비트 논리 연산자 `~, &, |, ^` 와 비트 이동 연산자 `<<. >>, >>> ` 로 구분한다. 비트 이동 연산자는 비트를 좌측 또는 우측으로 이동하는 연산자 이다.

비트 논리 연산자는 `~, &, |, ^` 가 있다. `&, |, ^` 연산자는 피연산자가 boolean 타입일 경우에는 일반 논리 연산자이고, 피연산자가 정수 타입일 경우에는 비트 논리 연산자로 사용된다. 

`~` 의 경우 비트 반전 연산자로 정수타입의 피연산자에만 사용되며, 피연산자를 2진수로 표현했을 때 비트값인 0을 1로 , 1은 0으로 반전한다. 연산 후, 부호 비트인 최상위 비트를 포함해서 모든 비트가 반전되기 때문에, 부호가 반대인 새로운 값이 산출된다. 

비트 반전 연산자를 사용할 때 주의할 점은 비트 반전 연산자 산출 타입은 int 타입이 된다는 것이다.

다시 비트 논리 연산자로 돌아와 `&, |, ^`  종류와 기능에 대해 설명하자면,

AND(논리곱) 으로 1 & 1 = 1, 1 & 0 = 0, 0 & 1 = 0, 0 & 0 = 0 으로 두 비트 모두 1일 경우에만 연산결과가 1이된다.

OR(논리합)은 1 | 1 = 1, 1 | 0 = 1, 0 | 1 = 1, 0 | 0 = 0 으로 두 비트 중 하나만 1이면 연산결과는 1이다.

XOR(배타적 논리합) 1 ^ 1 = 0, 1 ^ 0 = 1, 0 ^ 1 = 1, 0 ^ 0 = 0으로 두 비트 중 하나는 1이고 다른 하나가 0일 경우 연산 결과는 1이다.

NOT 논리 부정은 ` ~ ` 표시 이며 1 일때는 0 , 0 일때는 1이 되는 보수의 개념이다.

비트 연산자는 피연산자를 int 타입으로 자동 타입 변환 후 연산을 수행한다. 그렇기 때문에 byte, short, char 타입을 비트 논리 연산하면 그 결과는 int 타입이 된다.

따라서 아래의 그림은 에러가 난다.

<img src="https://github.com/sungpillhong/whiteshipstudy/blob/master/screenshot/5.PNG"> </img>



실제로 45와 25의 비트 연산은 4byte인 int 타입으로 변환된 후 다음과 같이 연산된다.

00000000 00000000 00000000 00101101 = 45

​								&

00000000 00000000 00000000 00011001 = 25

`----------------------------------`

00000000 00000000 00000000 00001001 = 9









#### 3. 관계 연산자





#### 4. 논리 연산자

#### 5. instanceof

#### 6. assignment(=) operator

#### 7. 화살표(->) 연산자

#### 8. 3항 연산자

#### 9.연산자 우선 순위

#### 10. (optional) Java 13. switch 연산자

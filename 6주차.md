# 6주차

- 자바 상속의 특징
- super 키워드
- 메소드 오버라이딩
- 다이나믹 메소드 디스패치 (Dynamic Method Dispatch)
- 추상 클래스
- final 키워드
- Object 클래스



### 1. 자바 상속의 특징

현실에서 상속은 부모가 자식에게 물려주는 행위를 말한다.

자식은 상속을 통해서 부모가 물려준 것을 자연스럽게 이용할 수 있다. 객체 지향 프로그램에서도 부모 클래스의 멤버를 자식 클래스에게 물려줄 수 있다.

<img src="https://github.com/sungpillhong/whiteshipstudy/blob/master/screenshot/상속.PNG"> </img>

(출처: https://kephilab.tistory.com/56)



상속은 이미 잘개발된 클래스를 재사용해서 새로운 클래스를 만들기 때문에 코드의 중복을 줄여준다.

field1, field2, method1(), method2()를 가지는 클래스를 작성한다고 생각해보자. 4개를 모두 처음부터 작성하는 것보다는 field1과 method1()을 가지고 있는 클래스가 있다면 이것을 상속하고, field2와 method2()만 추가 작성하는 것이 보다 효율적이고 개발 시간을 절약시켜준다.



상속을 해도 부모 클래스의 모든 필드와 메소드들을 물려받는 것은 아니다. 부모 클래스에서 private 접근 제한을 갖는 필드와 메소드는 상속 대상에서 제외된다.

그리고 부모 클래스와 자식 클래스가 다른 패키지에 존재한다면 default 접근 제한을 갖는 필드와 메소드도 상속 대상에서 제외된다.



자식 클래스를 선언할 때 어떤 부모 클래스를 상속받을 것인지를 결정하고 선택된 부모 클래스는 다음과 같이 extends 뒤에 기술한다.

```
class 자식클래스 extends 부모클래스 {
	//필드
	//생성자
	//메소드
}
```

예를 들어 Car 클래스를 상속해서 SportsCar 클래스를 설계하고 싶다면 다음과 같이 작성하면 된다.

```
class SportsCar extends Car{
	
}
```

 다른 언어와는 달리 자바는 다중 상속을 허용하지 않는다.

```
class SportsCar extends Car, 다른부모클래스{
 	//이건 안돼!!!
}
```



자바에서는 자식 객체를 생성하면, 부모 객체가 먼저 생성되고 자식 객체가 그 다음에 생성된다.

```
SportsCar sportsCar = new SportsCar();
```

위의 코드는 SportCar 객체만 생성하는 것 처럼 보이지만, 사실은 내부적으로 부모인 Car 객체가 먼저 생성되고, SportsCar 객체가 생성된다.



dmbCellPhone이 SportsCar로 생각하면되고 CellPhone이 Car라고 생각하면 된다.

<img src="https://github.com/sungpillhong/whiteshipstudy/blob/master/screenshot/상속2.PNG"> </img>

(출처: https://kephilab.tistory.com/56)





### 2. super 키워드



모든 객체는 클래스의 생성자를 호출해야만 생성된다. 부모 객체도 예외는 아니다. 그렇다면 부모 객체를 생성하기 위해 부모 생성자를 어디서 호출한 것인가?

이것에 대한 비밀은 자식 생성자에 숨어 있다. 부모 생성자는 자식 생성자의 맨 첫 줄에서 호출된다. 예를 들어 SportCar의 생성자가 명시적으로 선언되지 않았다면

컴파일러는 다음과 같은 기본 생성자를 생성해 낸다.

```
public SportsCar(){
	super();
}
```

첫줄에 super(); 가 추가된 것을 볼 수 있다.  super()는 부모의 기본 생성자를 호출한다. 즉 Car 클래스의 다음 생성자를 호출한다.

```
public Car(){
	
}
```

만약 직접 자식 생성자를 선언하고 명시적으로 부모 생성자를 호출하고 싶다면 다음과 같이 작성하면 된다.

```
자식클래스(매개변수선언, ...){
	super(매개값, ...);
	...
}
```



다음의 예를 한번 보자

```
//부모클래스
public class People{
	public String name;
	public String ssn;
	
	public People(String name, String ssn){
		this.name = name;
		this.ssn = ssn;
	}
}
```

People 클래스는 기본 생성자가 없고 name과 ssn을 매개값으로 받아 객체를 생성시키는 생성자만 있다. 

그렇기 때문에 People을 상속하는 Student 클래스는 생성자에서 super(name, ssn) 으로 People 클래스의 생성자를 호출해야 한다.

```
//자식클래스
public class Student extends People{
	public int studentNo;
	
	public Student(String name, String ssn, int studentNo){
		super(name, ssn);
		this.studentNo = studentNo;
	}
}
```

Student 클래스의 생성자는 name, ssn, studentNo를 매개값으로 받아서 name과 ssn은 다시 부모 생성자를 호출하기 위해 매개값으로 넘겨준다. 

super(name, ssn); 을 주석처리하면 컴파일 오류가 발생한다. 이것은 부모의 기본 생성자가 없으니 다른 생성자를 명시적으로 호출하라는 것이다.



### 3. 메소드 오버라이딩

부모 클래스의 모든 메소드가 자식 클래스에게 맞게 설계되어 있다면 가장 이상적인 상속이지만, 어떤 메소드는 자식 클래스가 사용하기에 적합하지 않을 수도 있다.

이 경우 상속된 일부 메소드는 자식 클래스에서 다시 수정해서 사용해야 한다.



메소드 오버라이딩은 상속된 메소드의 내용이 자식 클래스에 맞지 않을 경우, 자식 클래스에서 동일한 메소드를 재정의하는 것을 말한다. 메소드가 오버라이딩되었다면 부모 객체의 메소드는 숨겨지기 때문에, 자식 객체에서 메소드를 호출하면 오버라이딩된 자식 메소드가 호출된다.



<img src="https://github.com/sungpillhong/whiteshipstudy/blob/master/screenshot/상속3.PNG"> </img>

(출처: https://kephilab.tistory.com/56)



메소드를 오버라이딩할 때는 다음과 같은 규칙에 주의해서 작성해야 한다.

* 부모의 메소드와 동일한 시그니처(리턴타입, 메소드이름, 매개변수리스트)를 가져야 한다.
* 접근 제한을 더 강하게 오버라이딩할 수 없다.
* 새로운 예외(Exception)를 throws할 수 없다

접근 제한을 더 강하게 오버라이딩할 수 없다는 것은 부모 메소드가 public 접근 제한을 가지고 있을 경우 오버라이딩하는 자식 메소드는 default나 private 접근 제한으로 수정할 수 없다는 뜻이다.

반대는 가능하다. 부모 메소드가 default 접근 제한을 가지면 재정의되는 자식 메소드는 default 또는 public 접근 제한을 가질 수 있다.



````
//부모클래스
public class Animal{
	public String eat(){
		return "냠냠";
	}
}

//자식클래스
public class Cow extends Animal{
	@Overrid
	public String eat(){
		retrun "쩝쩝";
	}
}

//메인
public class example{
	public static void main(String[] args){
		Animal animal = new Animal();
        System.out.println(animal.eat()); //냠냠
        
        Cow cow = new Cow();
        System.out.println(cow.eat()); //쩝쩝
        
	}
} 
````



부모 메소드 호출(super)

자식 클래스에서 부모 클래스의 메소드를 오버라이딩하게 되면, 부모 클래스의 메소드는 숨겨지고 오버라이딩된 자식 메소드만 사용된다.

그러나 자식 클래스 내부에서 오버라이딩된 부모 클래스의 메소드를 호출해야 하는 상황이 발생한다면 명시적으로 super 키워드를 붙여서 부모 메소드를

호출할 수 있다. super는 부모 객체를 참조하고 있기 때문에 부모 메소드에 직접 접근할 수 있다.



```
super.부모메소드();
```



<img src="https://github.com/sungpillhong/whiteshipstudy/blob/master/screenshot/상속4.PNG"> </img>

(출처: https://kephilab.tistory.com/56)



Airplane 클래스를 상속해서 SuperSonicAirplane 클래스를 만들어보자. Airplane의 fly() 메소드는 일반 비행이지만 SuperSonicAirplane의 fly() 는 초음속 비행 모드와 일반 비행 모드 두가지로 동작하도록 설계해보자.

```
//Airplane.java

public class Airplane{
	
	public void land(){
		System.out.println("착륙합니다.");
	}
	
	public void fly(){
		System.out.println("일반 비행합니다.");
	}
	
	public void takeOff(){
		System.out.println("이륙합니다.");
	}
}
```

```
//SuperSonicAirplane.java

public class SuperSonicAirplane extends Airplane{
	public static final int NORMAL = 1;
	public static finla int SUPERSONIC = 2;
	
	public int flyMode = NORMAL;
	
	@Override
	public void fly(){
		if(flyMode == SUPERSONIC){
			System.out.println("초음속 비행합니다.");
		}else{
			//Airplane 객체의 fly() 메소드 호출
			super.fly();
		}
	}
}
```

```
//SuperSonicAirplaneExample.java

public class SuperSonicAirplaneExample {
	public static void main(String[] args){
		SuperSonicAirplane sa = new SuperSonicAirplane();
		sa.takeOff();
		sa.fly();
		sa.flyMode = SuperSonicAirplane.SUPERSONIC;
		sa.fly();
		sa.flyMode = SuperSonicAirplane.NORMAL;
		sa.fly();
		sa.land();
	}
}
```

```
//결과
이륙합니다.
일반 비행합니다.
초음속 비행합니다.
일반 비행합니다.
착륙합니다.
```



### 다이나믹 메소드 디스패치 (Dynamic Method Dispatch)

Method Dispatch란 어떤 메소드를 호출할지 결정하여 실제로 실행시키는 과정을 말한다.

dispatch는 static dispatch와 dynamic dispatch가 있는데 static은 구현클래스를 이용해 컴파일타임에서부터 어떤 메서드가 호출될지 정해져있는것이고, dynamic은 인터페이스를 이용해 참조함으로서 호출되는 메서드가 동적으로 정해지는걸 말한다.



* ***Static Dispatch***

자바에서 객체 생성은 런타임시에 호출된다. 즉 컴파일타임에 알수있는건 타입에 대한 정보이다. 타입자체가 Dispatch라는 구현클래스이기때문에 해당 메서드를 호출하면 어떤 메서드가 호출될지 정적으로 정해진다. 이에대한 정보는 컴파일이 종료된 후 바이트코드에도 드러나게된다.

```
public class Test {
    public static void main(String[] arg) {
        Dispatch dispatch = new Dispatch();
        System.out.println(dispatch.method());
    }
}

class Dispatch{
    public String method(){
        return "hello dispatch";
    }
}

```







* ***Dynamic Dispatch***

인터페이스를 타입으로 메서드를 호출한다. 컴파일러는 타입에 대한 정보를 알고있으므로 런타임시에 호출 객체를 확인해 해당 객체의 메서드를 호출한다. 런타임시에 호출 객체를 알 수 있으므로 바이트코드에도 어떤 객체의 메서드를 호출해야하는지 드러나지 않는다.

예제코드에서 method() 메서드는 인자가 없는 메서드이지만 자바는 묵시적으로 항상 호출 객체를 인자로 보내게된다. 호출 객체를 인자로 보내기때문에 this를 이용해 메서드 내부에서 호출객체를 참조할 수 있는 것이다



```
public class Test {
    public static void main(String[] arg) {
        Dispatchable dispatch = new Dispatch();
        System.out.println(dispatch.method());
    }
}

class Dispatch implements Dispatchable {
    public String method(){
        return "hello dispatch";
    }
}

interface Dispatchable{
    String method();
}

```





### 더블 메소드 디스패치 (Double Method Dispatch)



Double Dispatch는 Dynamic Dispatch를 두번하는 것이다. 



```
public class Test {
    public static void main(String[] arg) {
        List<SmartPhone> phoneList = Arrays.asList(new Iphone(), new Gallaxy());
        Game game = new Game();
        phoneList.forEach(game::play);
    }
}

interface SmartPhone{
}

class Iphone implements SmartPhone{

}

class Gallaxy implements SmartPhone{

}

class Game {
    public void play(SmartPhone phone) {
        System.out.println("game play [" +phone.getClass().getSimpleName()+ "]");
    }
}

```

스마트폰 리스트를 순회하면서 각각 게임을 하고있다. 스마트폰 리스트 인터페이스를 타입파라미터로 전달했기때문에 동적디스패치로 인해 출력내용은 모두 다르다. 앞에서 말했듯이 이는 인터페이스로 참조하고있는 객체 레퍼런스를 동적으로 추적하기때문이다.

만약 Game play가 스마트폰 구현체별로 다르게 구현되어야한다면 어떻게될까?

```
class Game {
    public void play(SmartPhone phone) {
    
        if(phone instanceof Iphone) {
            System.out.println("iphone play [" + phone.getClass().getSimpleName() + "]");
        }

        if(phone instanceof Gallaxy) {
            System.out.println("gallaxy play [" + phone.getClass().getSimpleName() + "]");
        }
    }
}

```

이런 방법이 있긴 하지만 만약 SmartPhone의 구현체로 Optimus가 추가된다면 Game 클래스까지 변경이 발생하게되어서 그렇게 효율적인 느낌은 아니다.

자바에서 지원을 하고말고는 논외로하고 잠깐 생각해본다면, 어차피 런타임시에 어떤 객체가 들어오는지를 확인해서 서로 다른 메서드를 호출해주는 동적 디스패치가 존재한다면 이를 인자에도 적용할 수 있지 않을까? 그렇게되면 알맞은 SmartPhone 구현체를 확인해 알아서 각각 메서드를 호출시켜주면 참 고마울것이다. 하지만 자바에서는 그런걸 지원하지않는다. 이런 이유로 자바를 *싱글 디스패치(Single Dispatch) 언어*라고 한다.



수정을 해보자

```
interface SmartPhone{
    void game(Game game);
}

class Iphone implements SmartPhone{
    @Override
    public void game(Game game) {
        System.out.println("iphone play [" + this.getClass().getSimpleName() + "]");
    }
}

class Gallaxy implements SmartPhone{
    @Override
    public void game(Game game) {
        System.out.println("gallaxy play [" + this.getClass().getSimpleName() + "]");
    }
}

class Game {
    public void play(SmartPhone phone) {
        phone.game(this);
    }
}
```

기존 Game클래스에 존재하던 비즈니스 로직을 각각 자기자신이 직접 처리하게끔 수정했다. 

이때는 디스패치가 2번 일어나게되는데 play() 메서드를 찾기위한 정적 디스패치가 발생하고, game()메서드를 호출하는 객체를 찾기위한 동적 디스패치가 발생하게된다. 

나는 지금 Game 클래스를 구현 클래스로 만들었기때문에 정적1번 동적1번이 발생하지만 Game 클래스역시 인터페이스를 기반으로 구현하여 인터페이스로 참조를 하게된다면 동적 디스패치가 2번 발생할것이다. 처음이 정적이든 동적이든 play() 메서드를 찾기위한 디스패치만 발생하던 기존 코드에서 play() 메서드 내부에 비즈니스로직을 호출하는 실제 객체를 찾기위한 *동적 디스패치가 1번 더 발생하면서 더블 디스패치(Double Dispatch)가 되는 것*이다.









참고 문헌 

------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------

이것이 자바다

출처: https://multifrontgarden.tistory.com/133 [우리집앞마당]
# 6주차

- 자바 상속의 특징
- super 키워드
- 메소드 오버라이딩
- 다이나믹 메소드 디스패치 (Dynamic Method Dispatch)
- 추상 클래스
- final 키워드
- Object 클래스



### 1. 자바 상속의 특징

현실에서 상속은 부모가 자식에게 물려주는 행위를 말한다.

자식은 상속을 통해서 부모가 물려준 것을 자연스럽게 이용할 수 있다. 객체 지향 프로그램에서도 부모 클래스의 멤버를 자식 클래스에게 물려줄 수 있다.

<img src="https://github.com/sungpillhong/whiteshipstudy/blob/master/screenshot/상속.PNG"> </img>

(출처: https://kephilab.tistory.com/56)



상속은 이미 잘개발된 클래스를 재사용해서 새로운 클래스를 만들기 때문에 코드의 중복을 줄여준다.

field1, field2, method1(), method2()를 가지는 클래스를 작성한다고 생각해보자. 4개를 모두 처음부터 작성하는 것보다는 field1과 method1()을 가지고 있는 클래스가 있다면 이것을 상속하고, field2와 method2()만 추가 작성하는 것이 보다 효율적이고 개발 시간을 절약시켜준다.



상속을 해도 부모 클래스의 모든 필드와 메소드들을 물려받는 것은 아니다. 부모 클래스에서 private 접근 제한을 갖는 필드와 메소드는 상속 대상에서 제외된다.

그리고 부모 클래스와 자식 클래스가 다른 패키지에 존재한다면 default 접근 제한을 갖는 필드와 메소드도 상속 대상에서 제외된다.



자식 클래스를 선언할 때 어떤 부모 클래스를 상속받을 것인지를 결정하고 선택된 부모 클래스는 다음과 같이 extends 뒤에 기술한다.

```
class 자식클래스 extends 부모클래스 {
	//필드
	//생성자
	//메소드
}
```

예를 들어 Car 클래스를 상속해서 SportsCar 클래스를 설계하고 싶다면 다음과 같이 작성하면 된다.

```
class SportsCar extends Car{
	
}
```

 다른 언어와는 달리 자바는 다중 상속을 허용하지 않는다.

```
class SportsCar extends Car, 다른부모클래스{
 	//이건 안돼!!!
}
```



자바에서는 자식 객체를 생성하면, 부모 객체가 먼저 생성되고 자식 객체가 그 다음에 생성된다.

```
SportsCar sportsCar = new SportsCar();
```

위의 코드는 SportCar 객체만 생성하는 것 처럼 보이지만, 사실은 내부적으로 부모인 Car 객체가 먼저 생성되고, SportsCar 객체가 생성된다.



dmbCellPhone이 SportsCar로 생각하면되고 CellPhone이 Car라고 생각하면 된다.

<img src="https://github.com/sungpillhong/whiteshipstudy/blob/master/screenshot/상속2.PNG"> </img>

(출처: https://kephilab.tistory.com/56)





### 2. super 키워드



모든 객체는 클래스의 생성자를 호출해야만 생성된다. 부모 객체도 예외는 아니다. 그렇다면 부모 객체를 생성하기 위해 부모 생성자를 어디서 호출한 것인가?

이것에 대한 비밀은 자식 생성자에 숨어 있다. 부모 생성자는 자식 생성자의 맨 첫 줄에서 호출된다. 예를 들어 SportCar의 생성자가 명시적으로 선언되지 않았다면

컴파일러는 다음과 같은 기본 생성자를 생성해 낸다.

```
public SportsCar(){
	super();
}
```

첫줄에 super(); 가 추가된 것을 볼 수 있다.  super()는 부모의 기본 생성자를 호출한다. 즉 Car 클래스의 다음 생성자를 호출한다.

```
public Car(){
	
}
```

만약 직접 자식 생성자를 선언하고 명시적으로 부모 생성자를 호출하고 싶다면 다음과 같이 작성하면 된다.

```
자식클래스(매개변수선언, ...){
	super(매개값, ...);
	...
}
```



다음의 예를 한번 보자

```
//부모클래스
public class People{
	public String name;
	public String ssn;
	
	public People(String name, String ssn){
		this.name = name;
		this.ssn = ssn;
	}
}
```

People 클래스는 기본 생성자가 없고 name과 ssn을 매개값으로 받아 객체를 생성시키는 생성자만 있다. 

그렇기 때문에 People을 상속하는 Student 클래스는 생성자에서 super(name, ssn) 으로 People 클래스의 생성자를 호출해야 한다.

```
//자식클래스
public class Student extends People{
	public int studentNo;
	
	public Student(String name, String ssn, int studentNo){
		super(name, ssn);
		this.studentNo = studentNo;
	}
}
```

Student 클래스의 생성자는 name, ssn, studentNo를 매개값으로 받아서 name과 ssn은 다시 부모 생성자를 호출하기 위해 매개값으로 넘겨준다. 

super(name, ssn); 을 주석처리하면 컴파일 오류가 발생한다. 이것은 부모의 기본 생성자가 없으니 다른 생성자를 명시적으로 호출하라는 것이다.



### 3. 메소드 오버라이딩

부모 클래스의 모든 메소드가 자식 클래스에게 맞게 설계되어 있다면 가장 이상적인 상속이지만, 어떤 메소드는 자식 클래스가 사용하기에 적합하지 않을 수도 있다.

이 경우 상속된 일부 메소드는 자식 클래스에서 다시 수정해서 사용해야 한다.



메소드 오버라이딩은 상속된 메소드의 내용이 자식 클래스에 맞지 않을 경우, 자식 클래스에서 동일한 메소드를 재정의하는 것을 말한다. 메소드가 오버라이딩되었다면 부모 객체의 메소드는 숨겨지기 때문에, 자식 객체에서 메소드를 호출하면 오버라이딩된 자식 메소드가 호출된다.



<img src="https://github.com/sungpillhong/whiteshipstudy/blob/master/screenshot/상속3.PNG"> </img>

(출처: https://kephilab.tistory.com/56)



메소드를 오버라이딩할 때는 다음과 같은 규칙에 주의해서 작성해야 한다.

* 부모의 메소드와 동일한 시그니처(리턴타입, 메소드이름, 매개변수리스트)를 가져야 한다.
* 접근 제한을 더 강하게 오버라이딩할 수 없다.
* 새로운 예외(Exception)를 throws할 수 없다

접근 제한을 더 강하게 오버라이딩할 수 없다는 것은 부모 메소드가 public 접근 제한을 가지고 있을 경우 오버라이딩하는 자식 메소드는 default나 private 접근 제한으로 수정할 수 없다는 뜻이다.

반대는 가능하다. 부모 메소드가 default 접근 제한을 가지면 재정의되는 자식 메소드는 default 또는 public 접근 제한을 가질 수 있다.



````
//부모클래스
public class Animal{
	public String eat(){
		return "냠냠";
	}
}

//자식클래스
public class Cow extends Animal{
	@Overrid
	public String eat(){
		retrun "쩝쩝";
	}
}

//메인
public class example{
	public static void main(String[] args){
		Animal animal = new Animal();
        System.out.println(animal.eat()); //냠냠
        
        Cow cow = new Cow();
        System.out.println(cow.eat()); //쩝쩝
        
	}
} 
````



부모 메소드 호출(super)

자식 클래스에서 부모 클래스의 메소드를 오버라이딩하게 되면, 부모 클래스의 메소드는 숨겨지고 오버라이딩된 자식 메소드만 사용된다.

그러나 자식 클래스 내부에서 오버라이딩된 부모 클래스의 메소드를 호출해야 하는 상황이 발생한다면 명시적으로 super 키워드를 붙여서 부모 메소드를

호출할 수 있다. super는 부모 객체를 참조하고 있기 때문에 부모 메소드에 직접 접근할 수 있다.



```
super.부모메소드();
```



<img src="https://github.com/sungpillhong/whiteshipstudy/blob/master/screenshot/상속4.PNG"> </img>

(출처: https://kephilab.tistory.com/56)



Airplane 클래스를 상속해서 SuperSonicAirplane 클래스를 만들어보자. Airplane의 fly() 메소드는 일반 비행이지만 SuperSonicAirplane의 fly() 는 초음속 비행 모드와 일반 비행 모드 두가지로 동작하도록 설계해보자.

```
//Airplane.java

public class Airplane{
	
	public void land(){
		System.out.println("착륙합니다.");
	}
	
	public void fly(){
		System.out.println("일반 비행합니다.");
	}
	
	public void takeOff(){
		System.out.println("이륙합니다.");
	}
}
```

```
//SuperSonicAirplane.java

public class SuperSonicAirplane extends Airplane{
	public static final int NORMAL = 1;
	public static finla int SUPERSONIC = 2;
	
	public int flyMode = NORMAL;
	
	@Override
	public void fly(){
		if(flyMode == SUPERSONIC){
			System.out.println("초음속 비행합니다.");
		}else{
			//Airplane 객체의 fly() 메소드 호출
			super.fly();
		}
	}
}
```

```
//SuperSonicAirplaneExample.java

public class SuperSonicAirplaneExample {
	public static void main(String[] args){
		SuperSonicAirplane sa = new SuperSonicAirplane();
		sa.takeOff();
		sa.fly();
		sa.flyMode = SuperSonicAirplane.SUPERSONIC;
		sa.fly();
		sa.flyMode = SuperSonicAirplane.NORMAL;
		sa.fly();
		sa.land();
	}
}
```

```
//결과
이륙합니다.
일반 비행합니다.
초음속 비행합니다.
일반 비행합니다.
착륙합니다.
```



### 다이나믹 메소드 디스패치 (Dynamic Method Dispatch)



















참고 문헌 

------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------

이것이 자바다

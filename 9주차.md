# 9주차

- 자바에서 예외 처리 방법 (try, catch, throw, throws, finally)
- 자바가 제공하는 예외 계층 구조
- Exception과 Error의 차이는?
- RuntimeException과 RE가 아닌 것의 차이는?
- 커스텀한 예외 만드는 방법

-------------------------------------------------------------------------



예외란 사용자의 잘못된 조작 또는 개발자의 잘못된 코딩으로 인해 발생하는 프로그램 오류를 말한다.



### 1. 자바에서 예외 처리 방법 (try, catch, throw, throws, finally)

프로그램에서 예외가 발생했을 경우 프로그램의 갑작스러운 종료를 막고, 정상 실행을 유지할 수 있도록 처리하는 코드를 예외 처리 코드라고 한다.

예외 처리 코드는 try-catch-finally 블록을 이용한다.

try-catch-finally 블록은 생성자 내부와 메소드 내부에서 작성되어 일반 예외와 실행 예외가 발생할 경우 예외 처리를 할 수 있도록 해준다.

```
//정상 실행

try {
	//예외 발생 가능 코드
}catch(예외클래스 e){
	//예외가 발생했을때만 
}finally{
	항상실행;
}
```

```
//예외가 발생할 경우

try {
	//예외 발생
}catch(예외클래스 e){
	//여기서 예외처리
}finally{
	//항상실행;
}
```

try 블록에는 예외 발생 가능 코드가 위치한다. try 블록의 코드가 예외 발생 없이 정상 실행되면 catch 블록의 코드는 실행되지 않고 finally 블록의 코드를 실행한다. 만약 try 블록의 코드에서 예외가 발행하면 즉시 실행을 멈추고 catch 블록으로 이동하여 예외 처리 코드를 실행한다.

finally 블록에는 예외 발생 여부와 상관없이 항상 실행한다. 





```
public class TryCatchFinallyExample {
	public static void main(String[] args){
		try{
			Class clazz = Class.forName("java.lang.String2");
		}catch(ClassNotFoundException e){
			System.out.println("클래스가 존재하지 않습니다.");
		}
	}
}
//실행결과
클래스가 존재하지 않습니다.
```

위 예제에서 Class.forName() 메소드는 매개값으로 주어진 클래스가 존재하면 Class 객체를 리턴하지만, 존재하지 않으면 ClassNotFoundException 예외를 발생시킨다.



#### 다중 catch

try 블록 내부는 다양한 종류의 예외가 발생할 수 있다. 이 경우, 발생되는 예외별로 예외 처리 코드를 다르게 하려면 어떻게 하면 될까?

이것에 대한 해답은 다중 catch 블록을 작성하는 것이다.

catch 블록의 예외 클래스 타입은 try 블록에서 발생된 예외의 종류를 말하는데, try 블록에서 해당 타입의 예외가 발생하면 catch 블록을 실행하도록 되어 있다.



```
try{
	//ArrayIndexOutOfBoundException 발생
	
	//NumberFormatException 발생
} catch(ArrayIndexOutOfBoundException e){
	//예외 처리1
} catch(NumberFormatException e){
	//예외 처리2
}
```

catch 블록이 여러 개라 할지라도 단 하나의 catch 블록만 실행된다.

그 이유는 try 블록에서 동시 다발적으로 예외가 발생하지 않고, 하나의 예외가 발생하면 즉시 실행을 멈추고 해당 catch 블록으로 이동하기 때문이다.

따라서 위의 코드에서는 ArrayIndexOutOfBoundException만 실행된다.



다중 catch 블록을 작성할 때 주의할 점은 상위 예외 클래스가 하위 예외 클래스보다 아래쪽에 위치 해야한다. try 블록에서 예외가 발생했을 때, 예외를 처리해줄 catch 블록이 위에 있다면, 하위 예외 클래스의 catch 블록은 실행되지 않는다. 왜냐하면 하위 예외는 상위 예외를 상속했기 때문에 상위 예외 타입도 되기 때문이다. 따라서 다음은 잘못 코딩한 것이다.

```
try {
	//ArrayIndexOutOfBoundException 발생
	
	//NumberFormatException 발생
} catch(Exception e){
	//예외 처리1
} catch(ArrayIndexOutOfBoundException e){
	//예외 처리2
}
```

ArrayIndexOutOfBoundException과 NumberFormatException은 모두 Exception을 상속 받기 때문에 첫 번째 catch 블록만 선택되어 실행된다.

두 번째 catch 블록은 어떤 경우에라도 실행되지 않는다. 위 코드는 다음과 같이 수정해야 한다.

```
try{
	//ArrayIndexOutOfBoundException 발생
	
	//NumberFormatException 발생
} catch(ArrayIndexOutOfBoundException e){
	//예외 처리1
} catch(Exception e){
	//예외 처리2
}
```



자바 7 부터 하나의 catch 블록에서 여러 개의 예외를 처리할 수 있도록 멀티  catch 기능을 추가했다.

다음은 멀티 catch 블록을 작성하는 방법을 보여준다. catch 괄호() 안에 동일하게 처리하고 싶은 예외를 |로 연결하면 된다.

```
try{
	//ArrayIndexOutOfBoundException 발생
	
	//NumberFormatException 발생	
}catch(ArrayIndexOutOfBoundException | NumberFormatException e){
	//예외 처리1
}catch(Exception e){
	//예외 처리2
}
```



#### throw

`throw` 키워드를 이용하면 인위적으로 예외를 발생시킬 수 있다.









#### throws



메소드 내부에서 예외가 발행할 수 있는 코드를 작성할 때 try-catch 블록으로 예외를 처리하는 것이 기본이지만, 경우에 따라서는 메소드를 호출한 곳으로 예외를 떠넘길 수도 있다. 이때 사용하는 키워드가 `throws`이다. 

`throws` 키워드는 메소드 선언부 끝에 작성되어 메소드에서 처리하지 않은 예외를 호출한 곳으로 떠넘기는 역할을 한다. 

`throws` 키워드 뒤에는 떠넘길 예외 클래스를 쉼표로 구분해서 나열해주면 된다.

```
리턴타입 메소드명(매개변수,...) throws 예외클래스1, 예외클래스2, ... {
	
}
```



발생할 수 있는 예외의 종류별로 throws 뒤에 나열하는 것이 일반적이지만, 다음과 같이 throws Exception 만으로 모든 예외를 간단히 떠넘길 수도 있다.

```
리턴타입 메소드명(매개변수,...) throws Exception {
	
}
```



throws 키워드가 붙어있는 메소드는 반드시 try 블록 내에서 호출되어야 한다. 그리고 catch 블록에서 떠넘겨 받은 예외를 처리해야 한다.

다음 코드는 throws 키워드가 있는 method2()를 method1() 에서 호출한느 방법을 보여준다.

```
public void method1(){
	try {
		method2();
	} catch(ClassNotFoundException e){
		//예외 처리 코드
		System.out.println("클래스가 존재하지 않습니다.");
	}
}

public void method2() throws ClassNotFoundException {
	Class clazz = Class.forName("java.lang.String2");
}
```

method1() 에서도 try-catch 블록으로 예외를 처리하지 않고 throws 키워드로 다시 예외를 떠넘길 수 있다. 그러면 method1() 을 호출하는 곳에서 결국 try-catch 블록을 사용해서 예외를 처리해야 한다.

```
public void method1() throws ClassNotFoundException {
	method2();
}
```









참고 문헌 

------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------

이것이 자바다
